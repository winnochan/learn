// Created by WinnoChan at 2024/04/17 00:26
// leetgo: 1.4.5
// https://leetcode.cn/problems/minimize-malware-spread-ii/

#include "LC_IO.h"
#include <bits/stdc++.h>
#include <iostream>
#include <sstream>
#include <vector>

using namespace std;

// @lc code=begin

class UnionFind {
public:
  UnionFind(int n) {
    root_list.resize(n);
    for (auto i = 0; i < n; ++i) {
      root_list[i] = i;
    }
    size_list.resize(n, 1);
  }

  int find(int x) {
    if (root_list[x] != x) {
      root_list[x] = find(root_list[x]);
    }
    return root_list[x];
  }

  void merge(int x, int y) {
    auto xi = find(x);
    auto yi = find(y);
    if (xi == yi)
      return;

    root_list[xi] = root_list[yi];
    size_list[yi] += size_list[yi];
  }

  bool is_same(int x, int y) { return find(x) == find(y); }

  int size_of(int x) { return size_list[find(x)]; }

private:
  vector<int> root_list;
  vector<int> size_list;
};

class Solution {
public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
    auto n = graph.size();

    // 病毒反查表
    vector<int> malwares(n);
    for (const auto i : initial) {
      malwares[i] = 1;
    }

    // 并查集
    UnionFind uf(n);

    // 邻接表遍历所有边
    for (auto i = 0; i < graph.size(); i++) {
      if (malwares[i])
        continue;

      auto nodes = graph[i];
      for (auto j = 0; j < nodes.size(); j++) {
        // cout << i << j << graph[i][j] << endl;
        if (malwares[j])
          continue;

        // 合并所有非病毒的点
        uf.merge(i, j);
      }
    }

    vector<int> comp_size(n);
    for (auto i = 0; i < graph.size(); i++) {
      if (malwares[i])
        continue;
      comp_size[uf.find(i)] = uf.size_of(i);
    }

    cout << comp_size << endl;

    auto ans = 0;

    return ans;
  }
};

// @lc code=end

int main() {
  ios_base::sync_with_stdio(false);
  stringstream out_stream;

  vector<vector<int>> graph;
  LeetCodeIO::scan(cin, graph);
  vector<int> initial;
  LeetCodeIO::scan(cin, initial);

  Solution *obj = new Solution();
  auto res = obj->minMalwareSpread(graph, initial);
  LeetCodeIO::print(out_stream, res);
  cout << "\noutput: " << out_stream.rdbuf() << endl;

  delete obj;
  return 0;
}
